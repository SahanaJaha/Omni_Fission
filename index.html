<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Omni-Fission</title>
  <style>
    :root { --bg:#0b0f14; --card:#121923; --ink:#dfe7f1; --muted:#8fa3b8; --accent:#59f; }
    html,body{height:100%;}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:linear-gradient(180deg,#0b0f14,#0d1220); color:var(--ink); display:grid; place-items:start center;}
    .wrap{width:min(1100px,95vw); margin:28px auto;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:14px;}
    h1{font-size:clamp(18px,2.6vw,24px); margin:0; letter-spacing:.3px; color:#eaf2ff}
    .panel{background:var(--card); border:1px solid #1e2a3a; border-radius:16px; padding:12px 14px; display:flex; flex-wrap:wrap; align-items:center; gap:10px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
    label{font-size:13px; color:var(--muted)}
    input[type="number"]{width:70px; background:#0f1520; color:var(--ink); border:1px solid #243044; padding:8px 10px; border-radius:10px}
    button{background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; box-shadow:0 8px 20px rgba(89,153,255,.35)}
    button.secondary{background:#1b2740; color:#cfe0ff; box-shadow:none; border:1px solid #223152}
    button:disabled{opacity:.5; cursor:not-allowed}
    .row{display:flex; gap:10px; align-items:center}
    .status{font-size:14px; color:#cfe0ff; margin-left:auto}
    .grid-wrap{display:grid; grid-template-columns: 1fr 340px; gap:14px; margin-top:14px}
    canvas{
      background:#2e151d;
      border:1px solid #1e2a3a;
      border-radius:16px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.4), 0 20px 50px rgba(0,0,0,.35);
    }
    .sidebar{background:var(--card); border:1px solid #1e2a3a; border-radius:16px; padding:14px}
    .log{height:260px; overflow:auto; background:#0d141f; border:1px solid #1e2a3a; border-radius:12px; padding:8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
    .legend{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0 6px}
    .dot{width:14px; height:14px; border-radius:50%}
    .w{background:#f2f5f9; border:1px solid #c8d0da}
    .b{background:#070b10; border:1px solid #2b374a}
    .hint{color:var(--muted); font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Omni-Fission</h1>
      <div class="row panel">
        <label>Rows <input id="rows" type="number" min="2" max="60" value="4"></label>
        <label>Cols <input id="cols" type="number" min="2" max="60" value="4"></label>
        <button id="newGame">New Game</button>
        <button id="randomize" class="secondary">Random 6 stones</button>
        <button id="setupBtn" class="secondary">Custom Setup</button>
        <span class="status" id="status">Loadingâ€¦</span>

        <!-- Setup palette -->
        <span id="setupTools" style="display:none; gap:10px; align-items:center" class="row">
          <span style="font-size:12px; color:#8fa3b8">Place:</span>
          <label><input type="radio" name="tool" value="1" checked> White</label>
          <label><input type="radio" name="tool" value="2"> Black</label>
          <label><input type="radio" name="tool" value="0"> Eraser</label>
          <button id="finishSetup">Done</button>
          <button id="clearSetup" class="secondary">Clear</button>
        </span>
      </div>
    </header>

    <div class="grid-wrap">
      <canvas id="board" width="720" height="540" aria-label="Game board" tabindex="0"></canvas>

      <aside class="sidebar">
        <!-- <div class="legend">
          <div class="dot w"></div><span>White = 1</span>
          <div class="dot b"></div><span>Black = 2</span>
        </div> -->
        <div class="row" style="margin:6px 0 10px">
          <button id="confirm" disabled>Confirm Move</button>
          <button id="cancel" class="secondary" disabled>Cancel</button>
        </div>
        <div class="hint">Rule: On your turn pick one of your stones, then choose 2â€“4 <em>orthogonal</em> empty neighbours to fill. The original stone is removed.
          If you have no legal origin with â‰¥2 empty orthogonal neighbours, you lose.
        </div>
        <h3 style="margin:12px 0 6px; font-size:14px; color:#cfe0ff">Move Log</h3>
        <div class="log" id="log" role="log"></div>
      </aside>
    </div>
  </div>

  <script>
    // --- Game State ---
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const newBtn = document.getElementById('newGame');
    const rndBtn = document.getElementById('randomize');
    const confirmBtn = document.getElementById('confirm');
    const cancelBtn = document.getElementById('cancel');
    const setupBtn = document.getElementById('setupBtn');
    const setupTools = document.getElementById('setupTools');
    const finishSetupBtn = document.getElementById('finishSetup');
    const clearSetupBtn = document.getElementById('clearSetup');

    // constants FIRST (fixes order bug)
    const EMPTY=0, WHITE=1, BLACK=2;

    let setupMode = false;
    let setupTool = WHITE; // 1=white, 2=black, 0=eraser

    let R=10, C=14, grid=[], cell=40, margin=20;
    let turn = WHITE; // white starts

    let origin = null;            // [r,c]
    let options = [];             // list of [r,c]
    let selectedTargets = new Set(); // Set of key "r,c"
    let phase = 'select-origin';

    function key(rc){ return rc[0]+","+rc[1]; }

    function initGrid(r,c){
      grid = Array.from({length:r},()=>Array(c).fill(EMPTY));
    }

    function centerStarts(){
      const rMid = Math.floor(R/2), cMid = Math.floor(C/2);
      grid[rMid][Math.max(0,cMid-3)] = WHITE;
      grid[rMid][Math.min(C-1,cMid+3)] = BLACK;
    }

    function randomStart(kEach=3){
      let spots = [];
      for(let r=0;r<R;r++) for(let c=0;c<C;c++) spots.push([r,c]);
      shuffle(spots);
      for(let i=0;i<kEach;i++){
        const a = spots.pop(); grid[a[0]][a[1]] = WHITE;
        const b = spots.pop(); grid[b[0]][b[1]] = BLACK;
      }
    }

    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} }

    function newGame(){
      R = clamp(parseInt(rowsInput.value)||10,2,60);
      C = clamp(parseInt(colsInput.value)||14,2,60);
      origin=null; options=[]; selectedTargets.clear(); phase='select-origin'; turn=WHITE;

      // leave setup mode if it was on
      setupMode = false;
      setupTools.style.display = 'none';

      initGrid(R,C); centerStarts();
      setStatus();
      logEl.innerHTML='';

      // canvas fit
      resizeCanvasToFit();
      if (enforceImmediateEndIfNoMoves()) return;
    }

    function setStatus(extra=""){
      // During setup, show only the instruction text
      if (phase === 'setup') {
        statusEl.textContent = "Click the coloured stone and where to place on the board";
        return;
      }

      // Normal (non-setup) status
      const t = (turn===WHITE ? "White" : "Black");
      const p = (phase==='select-origin') ? 'select a stone' : 'choose 2â€“4 targets';
      statusEl.textContent = `${t}'s turn Â· ${p} ${extra}`.trim();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // board background
      ctx.fillStyle = '#4b1f2f'; // deep maroon board fill
      roundRect(ctx, margin-6, margin-6, C*cell+12, R*cell+12, 14);
      ctx.fill();
      // grid lines
      for(let r=0;r<=R;r++) line(margin, margin+r*cell, margin+C*cell, margin+r*cell, '#815868');
      for(let c=0;c<=C;c++) line(margin+c*cell, margin, margin+c*cell, margin+R*cell, '#815868');

      // highlights for options
      if(origin && phase==='select-targets'){
        const [ro,co] = origin;
        highlightCell(ro,co,'rgba(255,255,255,0.12)');
        options.forEach(([r,c])=>{
          const sel = selectedTargets.has(key([r,c]));
          highlightCell(r,c, sel? 'rgba(89,153,255,0.35)': 'rgba(89,153,255,0.18)');
        });
      }

      // stones
      for(let r=0;r<R;r++){
        for(let c=0;c<C;c++){
          if(grid[r][c]!==EMPTY){
            drawStone(r,c, grid[r][c]===WHITE? '#f2f5f9' : '#111418', true);
          }
        }
      }

      // origin indicator
      if(origin && phase==='select-targets'){
        drawRing(origin[0],origin[1],'#ff99c8');
      }

      // enable/disable buttons
      const canConfirm = phase==='select-targets' && selectedTargets.size>=2 && selectedTargets.size<=4;
      confirmBtn.disabled = !canConfirm;
      cancelBtn.disabled = phase!=='select-targets';
    }

    function highlightCell(r,c, color){
      const x = margin + c*cell, y = margin + r*cell;
      ctx.fillStyle = color; roundRect(ctx, x+2, y+2, cell-4, cell-4, 8); ctx.fill();
    }

    function drawStone(r,c, fill, shadow=false){
      const x = margin + c*cell + cell/2; const y = margin + r*cell + cell/2; const rad = cell*0.35;
      if(shadow){ ctx.shadowColor='rgba(0,0,0,.6)'; ctx.shadowBlur=8; }
      ctx.fillStyle = fill; circle(ctx,x,y,rad); ctx.fill();
      ctx.shadowBlur=0;
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth=1; circle(ctx,x,y,rad); ctx.stroke();
    }

    function drawRing(r,c,color){
      const x = margin + c*cell + cell/2; const y = margin + r*cell + cell/2; const rad = cell*0.42;
      ctx.strokeStyle=color; ctx.lineWidth=2; circle(ctx,x,y,rad); ctx.stroke();
    }


    function circle(ctx,x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); }
    function line(x1,y1,x2,y2,color){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle=color; ctx.lineWidth=1; ctx.stroke(); }
    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); const rr=Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // --- Rules Helpers ---
    function orth(r,c){ return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([i,j])=> i>=0&&i<R&&j>=0&&j<C); }
    function empties(list){ return list.filter(([r,c])=> grid[r][c]===EMPTY); }
    function legalTargetsFrom(r,c){ return empties(orth(r,c)); }

    function hasAnyMove(player){
      for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(grid[r][c]===player){
        if(legalTargetsFrom(r,c).length>=2) return true;
      }
      return false;
    }

    function enforceImmediateEndIfNoMoves() {
      if (!hasAnyMove(turn)) {
        endGameDueToNoMoves(turn);
        return true; // ended
      }
      return false;
    }
    // ----- Setup mode helpers -----
    function enterSetup() {
      setupMode = true;
      phase = 'setup';
      initGrid(R, C); // fresh board; keep if you want a blank canvas
      setupTools.style.display = 'flex';
      confirmBtn.disabled = true;
      cancelBtn.disabled = true;
      setStatus();   // <-- now shows only the instruction line
      draw();
    }

    function exitSetup() {
      setupMode = false;
      setupTools.style.display = 'none';
      phase = 'select-origin';
      turn = WHITE; // White starts

      // ðŸ‘‡ Reset move log and note the custom start
      resetLogWith('Custom setup applied');

      setStatus();  // now shows "White's turn Â· select a stone"
      draw();

      // If you added the immediate-end rule, keep this:
      if (typeof enforceImmediateEndIfNoMoves === 'function' && enforceImmediateEndIfNoMoves()) return;
    }

    function clearSetup() {
      initGrid(R, C);
      draw();
    }

    function endGameDueToNoMoves(noMovePlayer){
      const winner = (noMovePlayer === WHITE) ? BLACK : WHITE;
      const score = countStones();
      // log(`Game over. ${nameOf(winner)} wins (opponent had no legal move). White:${score.white} Â· Black:${score.black}`);
      log(`Game over. ${nameOf(winner)} wins (opponent had no legal move)`);
      phase = 'game-over';
      setStatus('Â· Game over');
      draw();
    }

    function resetLogWith(message) {
      logEl.innerHTML = '';
      if (message) log(message);
    }

    function opponentOf(p){ return p===WHITE ? BLACK : WHITE; }

    // --- Interaction ---
    canvas.addEventListener('click', (e)=>{
      if (phase === 'select-origin' && enforceImmediateEndIfNoMoves()) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left - margin;
      const y = e.clientY - rect.top - margin;
      const c = Math.floor(x / cell); const r = Math.floor(y / cell);
      if(r<0||r>=R||c<0||c>=C) return;

      // SETUP MODE: direct place/erase
      if (phase === 'setup') {
        if (setupTool === EMPTY) grid[r][c] = EMPTY;
        else grid[r][c] = setupTool;
        draw();
        return;
      }

      if(phase==='select-origin'){
        if(grid[r][c]===turn){
          const opts = legalTargetsFrom(r,c);
          if(opts.length<2){
            flash(`${nameOf(turn)} stone at (${r+1},${c+1}) has < 2 empty orthogonal neighbours`);
            return;
          }
          origin = [r,c]; options = opts; selectedTargets.clear(); phase='select-targets';
          setStatus(); draw();
        }
      } else if(phase==='select-targets'){
        if(origin && r===origin[0] && c===origin[1]){ cancelSelection(); return; }
        if(options.some(([ri,ci])=>ri===r&&ci===c)){
          const k = key([r,c]);
          if(selectedTargets.has(k)){ selectedTargets.delete(k); }
          else if(selectedTargets.size<4){ selectedTargets.add(k); }
          draw();
        }
      }
    });

    confirmBtn.addEventListener('click', ()=>{
      if(phase!=='select-targets') return;
      if(selectedTargets.size<2 || selectedTargets.size>4) return;

      const [ro,co] = origin;
      grid[ro][co] = EMPTY; // remove origin
      selectedTargets.forEach(s=>{
        const [r,c] = s.split(',').map(Number);
        grid[r][c] = turn;
      });
      log(`${nameOf(turn)}: (${ro+1},${co+1}) -> { ${[...selectedTargets].map(s=>{
        const [r,c]=s.split(',').map(Number); return `(${r+1},${c+1})`;}).join(', ')} }`);

      // reset selection
      origin=null; options=[]; selectedTargets.clear(); phase='select-origin';

      // next player
      turn = (turn===WHITE)? BLACK : WHITE;

      // END IMMEDIATELY if the next player has no legal move
      if(!hasAnyMove(turn)){
        endGameDueToNoMoves(turn);
        return;
      }

      setStatus(); draw();
    });

    // Setup palette radio
    setupTools.addEventListener('change', (e) => {
      if (e.target && e.target.name === 'tool') {
        setupTool = parseInt(e.target.value, 10);
        setStatus(`Â· Setup mode â€” tool: ${setupTool===WHITE?'White':setupTool===BLACK?'Black':'Eraser'}`);
      }
    });

    confirmBtn.addEventListener('click', ()=>{
      if (phase !== 'select-targets') return;
      if (selectedTargets.size < 2 || selectedTargets.size > 4) return;

      const [ro,co] = origin;
      grid[ro][co] = EMPTY; // remove origin
      selectedTargets.forEach(s=>{
        const [r,c] = s.split(',').map(Number);
        grid[r][c] = turn;
      });
      log(`${nameOf(turn)}: (${ro+1},${co+1}) -> { ${[...selectedTargets].map(s=>{
        const [r,c]=s.split(',').map(Number); return `(${r+1},${c+1})`;}).join(', ')} }`);

      // reset selection
      origin=null; options=[]; selectedTargets.clear(); phase='select-origin';

      // switch turn
      turn = (turn===WHITE)? BLACK : WHITE;

      // END IMMEDIATELY if the next player has no legal move
      if (enforceImmediateEndIfNoMoves()) return;

      setStatus(); draw();
    });


    // cancelBtn.addEventListener('click', cancelSelection);

    function cancelSelection(){ origin=null; options=[]; selectedTargets.clear(); phase='select-origin'; setStatus(); draw(); }

    newBtn.addEventListener('click', newGame);
    rndBtn.addEventListener('click', ()=>{
      newGame();
      randomStart(3);
      draw();
      resetLogWith('Randomized start (3 each)');
    });

    // Setup buttons
    setupBtn.addEventListener('click', enterSetup);
    finishSetupBtn.addEventListener('click', exitSetup);
    clearSetupBtn.addEventListener('click', clearSetup);

    function countStones(){
      let w=0,b=0; for(let r=0;r<R;r++) for(let c=0;c<C;c++){ if(grid[r][c]===WHITE)w++; else if(grid[r][c]===BLACK)b++; }
      return {white:w, black:b};
    }

    function nameOf(p){ return p===WHITE? 'White':'Black'; }

    function log(msg){
      const t = new Date().toLocaleTimeString();
      logEl.innerHTML += `[${t}] ${msg}<br/>`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function flash(msg){
      statusEl.textContent = `${nameOf(turn)}'s turn Â· ${msg}`;
      setTimeout(()=> setStatus(), 1200);
    }

    // canvas size / HiDPI
    function resizeCanvasToFit() {
      const parent = canvas.parentElement;
      const maxW = (parent?.clientWidth || window.innerWidth) * 0.98;
      const maxH = window.innerHeight * 0.85;

      const usableW = Math.max(100, maxW - margin * 2);
      const usableH = Math.max(100, maxH - margin * 2);

      const cellW = Math.floor(usableW / C);
      const cellH = Math.floor(usableH / R);
      cell = Math.max(10, Math.min(cellW, cellH));

      const cssW = C * cell + margin * 2;
      const cssH = R * cell + margin * 2;
      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";

      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      draw();
    }

    window.addEventListener("resize", resizeCanvasToFit);

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !confirmBtn.disabled) {
        confirmBtn.click();
      }
    });


    // bootstrap
    newGame();
    resizeCanvasToFit();
  </script>
</body>
</html>
