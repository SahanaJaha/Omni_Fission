<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orthogonal Expansion Game</title>
  <style>
    :root { --bg:#0b0f14; --card:#121923; --ink:#dfe7f1; --muted:#8fa3b8; --accent:#59f; }
    html,body{height:100%;}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:linear-gradient(180deg,#0b0f14,#0d1220); color:var(--ink); display:grid; place-items:start center;}
    .wrap{width:min(1100px,95vw); margin:28px auto;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:14px;}
    h1{font-size:clamp(18px,2.6vw,24px); margin:0; letter-spacing:.3px; color:#eaf2ff}
    .panel{background:var(--card); border:1px solid #1e2a3a; border-radius:16px; padding:12px 14px; display:flex; flex-wrap:wrap; align-items:center; gap:10px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
    label{font-size:13px; color:var(--muted)}
    input[type="number"]{width:70px; background:#0f1520; color:var(--ink); border:1px solid #243044; padding:8px 10px; border-radius:10px}
    button{background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; box-shadow:0 8px 20px rgba(89,153,255,.35)}
    button.secondary{background:#1b2740; color:#cfe0ff; box-shadow:none; border:1px solid #223152}
    button:disabled{opacity:.5; cursor:not-allowed}
    .row{display:flex; gap:10px; align-items:center}
    .status{font-size:14px; color:#cfe0ff; margin-left:auto}
    .grid-wrap{display:grid; grid-template-columns: 1fr 340px; gap:14px; margin-top:14px}
    canvas{background:#0d141f; border:1px solid #1e2a3a; border-radius:16px; box-shadow: inset 0 0 0 1px #0b111b, 0 20px 50px rgba(0,0,0,.25)}
    .sidebar{background:var(--card); border:1px solid #1e2a3a; border-radius:16px; padding:14px}
    .log{height:260px; overflow:auto; background:#0d141f; border:1px solid #1e2a3a; border-radius:12px; padding:8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
    .legend{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0 6px}
    .dot{width:14px; height:14px; border-radius:50%}
    .w{background:#f2f5f9; border:1px solid #c8d0da}
    .b{background:#070b10; border:1px solid #2b374a}
    .hint{color:var(--muted); font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Orthogonal Expansion (2–4 targets) – Browser Edition</h1>
      <div class="row panel">
        <label>Rows <input id="rows" type="number" min="2" max="60" value="10"></label>
        <label>Cols <input id="cols" type="number" min="2" max="60" value="14"></label>
        <button id="newGame">New Game</button>
        <button id="randomize" class="secondary">Random 6 stones</button>
        <span class="status" id="status">Loading…</span>
      </div>
    </header>

    <div class="grid-wrap">
      <canvas id="board" width="720" height="540" aria-label="Game board" tabindex="0"></canvas>

      <aside class="sidebar">
        <div class="legend">
          <div class="dot w"></div><span>White = 1</span>
          <div class="dot b"></div><span>Black = 2</span>
        </div>
        <div class="row" style="margin:6px 0 10px">
          <button id="confirm" disabled>Confirm Move</button>
          <button id="cancel" class="secondary" disabled>Cancel</button>
        </div>
        <div class="hint">Rule: On your turn pick one of your stones, then choose 2–4 <em>orthogonal</em> empty neighbours to fill. The original stone is removed.
          If you have no legal origin with ≥2 empty orthogonal neighbours, you pass.
        </div>
        <h3 style="margin:12px 0 6px; font-size:14px; color:#cfe0ff">Move Log</h3>
        <div class="log" id="log" role="log"></div>
      </aside>
    </div>
  </div>

  <script>
    // --- Game State ---
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const newBtn = document.getElementById('newGame');
    const rndBtn = document.getElementById('randomize');
    const confirmBtn = document.getElementById('confirm');
    const cancelBtn = document.getElementById('cancel');

    let R=10, C=14, grid=[], cell=40, margin=20;

    const EMPTY=0, WHITE=1, BLACK=2;
    let turn = WHITE; // white starts

    let origin = null;            // [r,c]
    let options = [];             // list of [r,c]
    let selectedTargets = new Set(); // Set of key "r,c"
    let phase = 'select-origin';

    function key(rc){ return rc[0]+","+rc[1]; }

    function initGrid(r,c){
      grid = Array.from({length:r},()=>Array(c).fill(EMPTY));
    }

    function centerStarts(){
      // Simple symmetric start
      const rMid = Math.floor(R/2), cMid = Math.floor(C/2);
      grid[rMid][Math.max(0,cMid-3)] = WHITE;
      grid[rMid][Math.min(C-1,cMid+3)] = BLACK;
    }

    function randomStart(kEach=3){
      let spots = [];
      for(let r=0;r<R;r++) for(let c=0;c<C;c++) spots.push([r,c]);
      shuffle(spots);
      for(let i=0;i<kEach;i++){
        const a = spots.pop(); grid[a[0]][a[1]] = WHITE;
        const b = spots.pop(); grid[b[0]][b[1]] = BLACK;
      }
    }

    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} }

    function newGame(){
      R = clamp(parseInt(rowsInput.value)||10,2,60);
      C = clamp(parseInt(colsInput.value)||14,2,60);
      origin=null; options=[]; selectedTargets.clear(); phase='select-origin'; turn=WHITE;
      // dynamic cell size to fit canvas
      const availW = canvas.width - margin*2, availH = canvas.height - margin*2;
      cell = Math.floor(Math.min(availW/C, availH/R));
      initGrid(R,C); centerStarts();
      setStatus();
      draw();
      logEl.innerHTML='';
    }

    function setStatus(extra=""){
      const t = (turn===WHITE?"White":"Black");
      const p = phase==='select-origin'?"select a stone": `choose 2–4 targets`;
      statusEl.textContent = `${t}'s turn · ${p} ${extra}`.trim();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // board background
      ctx.fillStyle = '#0b111b';
      roundRect(ctx, margin-6, margin-6, C*cell+12, R*cell+12, 14);
      ctx.fill();
      // grid lines
      for(let r=0;r<=R;r++) line(margin, margin+r*cell, margin+C*cell, margin+r*cell, '#1e2a3a');
      for(let c=0;c<=C;c++) line(margin+c*cell, margin, margin+c*cell, margin+R*cell, '#1e2a3a');

      // highlights for options
      if(origin){
        // origin glow
        const [ro,co] = origin;
        highlightCell(ro,co,'rgba(255,255,255,0.12)');
        options.forEach(([r,c])=>{
          const sel = selectedTargets.has(key([r,c]));
          highlightCell(r,c, sel? 'rgba(89,153,255,0.35)': 'rgba(89,153,255,0.18)');
        });
      }

      // stones
      for(let r=0;r<R;r++){
        for(let c=0;c<C;c++){
          if(grid[r][c]!==EMPTY){
            drawStone(r,c, grid[r][c]===WHITE? '#f2f5f9':'#0a0f15', true);
          }
        }
      }

      // origin indicator
      if(origin){
        drawRing(origin[0],origin[1],'#59f');
      }

      // enable/disable buttons
      const canConfirm = phase==='select-targets' && selectedTargets.size>=2 && selectedTargets.size<=4;
      confirmBtn.disabled = !canConfirm;
      cancelBtn.disabled = phase!=='select-targets';
    }

    function highlightCell(r,c, color){
      const x = margin + c*cell, y = margin + r*cell;
      ctx.fillStyle = color; roundRect(ctx, x+2, y+2, cell-4, cell-4, 8); ctx.fill();
    }

    function drawStone(r,c, fill, shadow=false){
      const x = margin + c*cell + cell/2; const y = margin + r*cell + cell/2; const rad = cell*0.35;
      if(shadow){ ctx.shadowColor='rgba(0,0,0,.6)'; ctx.shadowBlur=8; }
      ctx.fillStyle = fill; circle(ctx,x,y,rad); ctx.fill();
      ctx.shadowBlur=0;
      // subtle rim
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth=1; circle(ctx,x,y,rad); ctx.stroke();
    }

    function drawRing(r,c,color){
      const x = margin + c*cell + cell/2; const y = margin + r*cell + cell/2; const rad = cell*0.42;
      ctx.strokeStyle=color; ctx.lineWidth=2; circle(ctx,x,y,rad); ctx.stroke();
    }

    function circle(ctx,x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); }
    function line(x1,y1,x2,y2,color){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle=color; ctx.lineWidth=1; ctx.stroke(); }
    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); const rr=Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // --- Rules Helpers ---
    function orth(r,c){ return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([i,j])=> i>=0&&i<R&&j>=0&&j<C); }
    function empties(list){ return list.filter(([r,c])=> grid[r][c]===EMPTY); }

    function legalTargetsFrom(r,c){
      // From origin (must be your stone), available orthogonal empties
      return empties(orth(r,c));
    }

    function hasAnyMove(player){
      for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(grid[r][c]===player){
        if(legalTargetsFrom(r,c).length>=2) return true;
      }
      return false;
    }

    // --- Interaction ---
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left - margin;
      const y = e.clientY - rect.top - margin;
      const c = Math.floor(x / cell); const r = Math.floor(y / cell);
      if(r<0||r>=R||c<0||c>=C) return;

      if(phase==='select-origin'){
        if(grid[r][c]===turn){
          const opts = legalTargetsFrom(r,c);
          if(opts.length<2){
            flash(`${nameOf(turn)} stone at (${r+1},${c+1}) has < 2 empty orthogonal neighbours`);
            return;
          }
          origin = [r,c]; options = opts; selectedTargets.clear(); phase='select-targets';
          setStatus(); draw();
        }
      } else if(phase==='select-targets'){
        // toggle if clicked in options, else if clicked origin, cancel selection
        if(origin && r===origin[0] && c===origin[1]){ cancelSelection(); return; }
        if(options.some(([ri,ci])=>ri===r&&ci===c)){
          const k = key([r,c]);
          if(selectedTargets.has(k)){ selectedTargets.delete(k); }
          else if(selectedTargets.size<4){ selectedTargets.add(k); }
          draw();
        }
      }
    });

    confirmBtn.addEventListener('click', ()=>{
      if(phase!=='select-targets') return;
      if(selectedTargets.size<2 || selectedTargets.size>4) return;
      const [ro,co] = origin;
      grid[ro][co] = EMPTY; // remove origin
      selectedTargets.forEach(s=>{
        const [r,c] = s.split(',').map(Number);
        grid[r][c] = turn;
      });
      log(`${nameOf(turn)}: (${ro+1},${co+1}) -> { ${[...selectedTargets].map(s=>{
        const [r,c]=s.split(',').map(Number); return `(${r+1},${c+1})`;}).join(', ')} }`);

      // next turn
      origin=null; options=[]; selectedTargets.clear(); phase='select-origin';
      turn = (turn===WHITE)? BLACK : WHITE;

      // handle passes / end
      if(!hasAnyMove(turn)){
        log(`No legal move for ${nameOf(turn)} (pass)`);
        turn = (turn===WHITE)? BLACK : WHITE; // pass back
        if(!hasAnyMove(turn)){
          // both cannot move => end
          const score = countStones();
          log(`Game over. White:${score.white} · Black:${score.black}`);
          setStatus('· Game over');
          draw();
          return;
        }
      }
      setStatus(); draw();
    });

    cancelBtn.addEventListener('click', cancelSelection);

    function cancelSelection(){ origin=null; options=[]; selectedTargets.clear(); phase='select-origin'; setStatus(); draw(); }

    newBtn.addEventListener('click', ()=>{ newGame(); });
    rndBtn.addEventListener('click', ()=>{ newGame(); randomStart(3); draw(); log('Randomized start (3 each)'); });

    function countStones(){
      let w=0,b=0; for(let r=0;r<R;r++) for(let c=0;c<C;c++){ if(grid[r][c]===WHITE)w++; else if(grid[r][c]===BLACK)b++; }
      return {white:w, black:b};
    }

    function nameOf(p){ return p===WHITE? 'White':'Black'; }

    function log(msg){
      const t = new Date().toLocaleTimeString();
      logEl.innerHTML += `[${t}] ${msg}<br/>`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function flash(msg){
      statusEl.textContent = `${nameOf(turn)}'s turn · ${msg}`;
      setTimeout(()=> setStatus(), 1200);
    }

    // bootstrap
    newGame();
    // handle HiDPI crispness
    function resizeCanvasToFit() {
      // Available screen space minus some margins around the board
      const maxW = window.innerWidth * 0.9;
      const maxH = window.innerHeight * 0.9;

      // Compute max cell size that keeps board inside window
      const cellW = Math.floor(maxW / C);
      const cellH = Math.floor(maxH / R);
      cell = Math.max(10, Math.min(cellW, cellH)); // enforce minimum cell size

      // Update canvas real size
      canvas.style.width = (C * cell) + "px";
      canvas.style.height = (R * cell) + "px";

      // Account for HiDPI screens
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(C * cell * dpr);
      canvas.height = Math.floor(R * cell * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      draw();
    }

    window.addEventListener("resize", resizeCanvasToFit);
    resizeCanvasToFit();

  </script>
</body>
</html>
